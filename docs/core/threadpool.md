# 🧰 ThreadPool 模块

`ThreadPool` 模块是 HTTP 服务器的多线程任务调度核心，负责高效管理线程资源、异步执行客户端请求处理任务，并通过线程复用降低系统开销，提升服务器并发处理能力。

## ✨ 模块职责

- **线程生命周期管理**：创建并维护固定数量的工作线程，控制线程启动与终止。
- **任务队列调度**：接收外部提交的任务，按顺序分配给空闲线程执行。
- **资源安全回收**：在析构时安全停止所有线程，确保任务队列清空并回收资源。
- **异常捕获与日志**：捕获任务执行中的异常，记录错误信息避免进程崩溃。

## 📌 核心特性

- **线程复用机制**：避免频繁创建/销毁线程，减少系统资源消耗。
- **线程安全队列**：通过互斥锁和条件变量保证任务队列的并发安全访问。
- **优雅停机策略**：通过原子标志位通知线程退出，等待未完成任务完成。
- **动态任务分发**：支持任意可调用对象的异步执行，灵活适配不同任务类型。

## 📁 成员组成

| 类型/名称 | 描述 |
| ---- | ---- |
| `std::vector<std::thread> workers_` | 工作线程集合，每个线程执行 `workerLoop` 函数循环处理任务。 |
| `std::atomic<bool> stop_` | 原子标志位，标记线程池是否已停止，控制工作线程退出。 |
| `std::queue<std::function<void()>> tasks_` | 任务队列，存储待执行的函数对象。 |
| `std::mutex tasks_mutex_` | 互斥锁，保护任务队列的并发访问。 |
| `std::condition_variable condition_` | 条件变量，协调线程间任务通知与等待。 |

## ⚙️ 方法概览

| 方法名称 | 功能描述 |
| ---- | ---- |
| `enqueue` | 提交任务到队列，唤醒一个线程执行。 |
| `workerLoop` | 工作线程主循环，持续从队列中取出并执行任务。 |

## 🔄 工作流程

1. **线程池初始化**
   - 构造时创建指定数量的线程，每个线程启动 `workerLoop` 循环。
   - 线程进入等待状态，监听任务队列通知。
2. **任务提交阶段**
   - 通过 `enqueue` 接收外部任务，加入队列并唤醒一个等待线程。
   - 队列为空时，线程通过条件变量 `condition_` 阻塞以节省 CPU 资源。
3. **任务执行阶段**
   - 线程被唤醒后，从队列头部取出任务并执行。
   - 任务执行过程包裹在 `try-catch` 块中，捕获异常并记录日志。
4. **线程退出控制**
   - 析构时设置 `stop_` 为 `true`，广播条件变量通知所有线程。
   - 线程检查 `stop_` 标志，若为 `true` 且队列为空，则安全退出循环。
   - 主线程调用 `join` 等待所有工作线程终止。
5. **异常处理流程**
   - 任务执行中抛出的异常被捕获，记录错误类型和线程 ID。
   - 线程继续处理后续任务，避免因单个任务失败导致线程终止。

## 🔑 关键设计

- **条件变量优化**：使用 `condition_variable::wait` 的谓词重载，避免虚假唤醒。
- **资源泄露防护**：析构时强制等待线程结束，确保任务队列完全清空。
- **原子操作保障**：通过 `std::atomic<bool>` 实现无锁状态同步，保证停机指令的可见性。
